프로젝트 2에서 스택은 `USER_STACK`에서 시작하는 단일 페이지였기 때문에 프로그램의 실행도 스택의 사이즈로 인해 일정 한계가 있었습니다.
하지만 이제는 우리가 필요에 따라 추가적인 스택을 할당해야합니다.

추가적인 스택 할당은 오직 특정한 주소 접근이 스택에 대한 접근으로 "보일 때" 일어납니다.
따라서 우리는 특정 주소에 대한 접근이 스택 접근인지 판단하기 위한 heuristic을 고안해야합니다.

![[StackGrowth.png]]

우리는 `syscall_handler` 또는 `page_fault` 상황에서 `struct intr_frame`에서 `rsp`를 얻어낼 수 있다.
우리가 유효하지 않은 메모리 접근을 감지하기 위해 `page_fault`에 의존한다면 주의할 점이 있다.
왜냐하면 프로세서는 사용자 모드에서 커널 모드로의 전환에서만 `struct intr_frame`의 `rsp`를 업데이트하기 때문이다.
따라서 우리는 커널 모드에서 페이지 폴트가 일어나는 상황에 대해서도 대처하기 위해서 `struct thread`에 `rsp`를 저장해두는 등의 방법에 대해서 생각해봐야한다.

#### `vm_try_handle_fault`
이 함수는 페이지 폴트 핸들링 과정 속에서 `page_fault` 함수에 의해 호출된다.
우리는 여기서 발생한 페이지 폴트가 유효한 스택 확장인지 확인하는 로직을 생성해야한다. (아마 휴리스틱이겠지..)
만약 스택 확장이라는 결론을 냈다면 그 주소에 대해서 `vm_stack_growth` 함수를 호출해라.

#### `vm_stack_growth`
이 함수에서 우리는 페이지 폴트가 났던 주소에 스택 페이지를 추가로 할당해야하는 과정을 거쳐야한다.
이 프로젝트에서 우리는 스택의 크기를 1MB로 제한해야한다.