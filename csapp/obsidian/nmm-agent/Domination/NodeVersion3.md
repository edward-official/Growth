## 1. 질문 분류기 (Question Classifier)

  

### 역할

사용자의 입력(질문)을 분석하여, 의도에 따라 서로 다른 워크플로우 경로로 라우팅하는 역할을 합니다. LLM(Large Language Model)의 추론 능력을 활용하여 자연어를 이해하고 분류합니다.

  

### 입력 (Input)

* **Query (입력 텍스트)**: 분류할 **대상**이 되는 실제 사용자 입력 텍스트입니다. (예: "배송 언제 되나요?")

* **Model**: 분류에 사용할 LLM 모델 설정입니다.

* **Classes**: 분류할 카테고리 목록입니다. 각 클래스는 고유한 ID와 이름을 가집니다. (예: `ID: 1, Name: 기술 지원`)

* **Instruction (분류 지침)**: LLM이 분류를 수행할 때 따라야 할 **규칙**이나 **기준**입니다. 쿼리에 포함되는 내용이 아니라, 시스템이 LLM에게 주는 별도의 가이드라인입니다. (예: "배송 관련 질문은 '배송 문의' 클래스로 분류해.")

* **Memory**: 선택적으로 대화 기록을 포함하여 문맥 기반의 분류를 수행할 수 있습니다.

* **작동 방식**: 설정된 **대화 턴 수**만큼의 최근 대화 기록을 가져와 `<histories>` 태그로 감싸서 시스템 프롬프트에 포함시킵니다. 이를 통해 LLM은 현재 질문뿐만 아니라 이전 대화의 흐름을 파악하여 더 정확한 분류를 수행할 수 있습니다. (예: 사용자가 "그거 얼마야?"라고 물었을 때, 이전 대화에서 '아이폰'에 대해 이야기하고 있었다면 '가격 문의' 클래스로 분류 가능)

* **Vision**: 이미지를 포함한 멀티모달 입력을 지원할 경우 이미지 데이터를 입력받습니다. (후순위)

  

### 처리 과정 (Process)

1. **프롬프트 구성**: 입력받은 `Query`, `Instruction`, `Classes`, `Memory`를 조합하여 LLM에게 보낼 프롬프트를 생성합니다.

2. **LLM 호출**: 구성된 프롬프트를 설정된 LLM 모델로 전송합니다.

3. **결과 파싱**: LLM이 생성한 응답(주로 JSON 형식)을 분석하여, 정의된 `Classes` 중 어느 것에 해당하는지 식별합니다. (예: `{"category_id": "1", "category_name": "기술 지원"}`)

4. **경로 분기**: 식별된 클래스 ID에 해당하는 경로로 워크플로우의 실행 흐름을 연결합니다.

  

### 출력 (Output)

* **class_name (String)**: 분류된 결과 클래스의 이름입니다.

* **class_id (String)**: 분류된 결과 클래스의 ID입니다. 다음 노드에서 조건 확인 등에 사용될 수 있습니다.

  

---

  

## 2. 조건 분기 (If/Else)

  

### 역할

설정된 조건의 참/거짓 여부에 따라 워크플로우의 실행 흐름을 제어합니다. 프로그래밍의 `if-else` 또는 `switch` 구문과 유사합니다.

  

### 입력 (Input)

* **Conditions (조건 목록)**: 비교할 변수와 기준값, 비교 연산자(예: contains, =, >)로 구성된 조건들입니다.

* **Logical Operator**: 여러 조건이 있을 경우 이를 결합하는 방식(`AND` 또는 `OR`)을 설정합니다.

* **Cases (케이스 그룹)**: 다중 분기의 경우, 각 분기별로 조건 그룹을 정의합니다.

  

### 처리 과정 (Process)

1. **순차 평가**: 정의된 케이스(Case)들을 위에서부터 순서대로 평가합니다.

2. **조건 검사**: 각 케이스 내부의 조건들을 설정된 논리 연산자(`AND/OR`)에 따라 평가합니다.

* 예: `(변수 A == "값 1") AND (변수 B contains "오류")`

3. **경로 선택**: 조건이 `True`로 평가되는 첫 번째 케이스를 발견하면, 해당 케이스의 경로를 선택하고 평가를 중단합니다.

4. **기본 경로(Else)**: 모든 케이스가 `False`인 경우, `Else` 경로를 선택합니다.

  

### 출력 (Output)

* **별도의 데이터 출력 없음**: 이 노드는 데이터 값을 생성하여 반환하기보다는, 흐름(Control Flow) 자체를 제어하는 역할을 합니다. 다만 내부적으로는 `result`(최종 평가 결과)와 `selected_case_id`를 관리합니다.

  

---

  

## 3. HTTP 요청 (HTTP Request)

  

### 역할

외부 시스템, API, 또는 웹훅(Webhook, 특정 이벤트가 발생했을 때 실시간으로 알림을 보내는 기술)과 통신하여 데이터를 보내거나 받아오는 역할을 합니다. Dify 워크플로우를 외부 세계와 연결하는 핵심 노드입니다.

  

### 입력 (Input)

* **Method**: HTTP 메서드 (`GET`, `POST`, `PUT`, `DELETE` 등).

* **URL**: 요청을 보낼 API 엔드포인트. 주소 내에 변수를 포함할 수 있습니다.

* **Headers**: 요청 헤더 (Key-Value 쌍). 인증 정보나 Content-Type 등을 명시합니다.

* **Params**: URL 쿼리 파라미터.

* **Body**: 요청 본문.

* `JSON`, `Form-data`, `x-www-form-urlencoded`, `Raw Text`, `Binary` 등 다양한 형식을 지원합니다.

* **Timeout / Retry Config**: 요청 타임아웃 시간 및 실패 시 재시도 횟수 설정. (외부 서버가 응답하지 않을 때 무한정 대기하는 것을 방지하고, 일시적인 네트워크 오류 시 재시도하여 안정성을 높임)

  

### 처리 과정 (Process)

1. **요청 구성**: 입력된 변수들을 실제 값으로 치환하여 URL, 헤더, 본문을 완성합니다.

2. **HTTP 통신**: 설정된 메서드와 구성된 데이터로 외부 서버에 요청을 전송합니다.

3. **응답 수신 및 파싱**: 외부 서버로부터 응답을 받습니다.

* 텍스트 응답의 경우 내용을 그대로 읽어들입니다.

* 파일(바이너리) 응답의 경우: **응답 헤더(Response Header)**에 있는 `Content-Disposition`(파일명 유무)이나 `Content-Type`(MIME 타입)을 확인하고, 일부 경우엔 **응답 바디(Response Body)**의 앞부분 1024바이트를 읽어서 텍스트인지 판단합니다. 파일로 판단되면 이를 파일 객체로 변환하여 내부 파일 관리 시스템에 저장합니다.

4. **오류 처리**: 연결 실패나 타임아웃 발생 시, 설정된 재시도 정책에 따라 재시도를 수행하거나 오류를 반환합니다.

  

### 출력 (Output)

다음 노드에서 사용할 수 있는 변수들을 반환합니다.

* **status_code (Number)**: HTTP 응답 상태 코드 (예: 200, 404, 500).

* **body (String)**: 응답 본문 텍스트입니다. (단, **파일**로 인식된 경우 이 값은 비워두고, 데이터는 `files` 변수로 이동합니다.)

* **headers (Object)**: 응답 헤더 정보입니다.

* **files (Array[File])**: 응답이 파일인 경우, 다운로드되거나 처리된 파일 객체들의 리스트입니다.

  

---

  

### [참고] HTTP Request 노드 vs 도구(Tool) 노드

  

* **HTTP Request 노드**: 사용자가 직접 URL, Method, Header, Body 등을 세팅해서 외부 API를 호출하는 **범용적인** 방식입니다.

* **도구(Tool) 노드**: Dify 내부(또는 플러그인)에 미리 정의된 **도구**들(예: Google Search, Wikipedia, DALL-E 등)을 가져와서 사용하는 방식입니다. 내부적으로 API를 호출한다는 점은 같지만, Tool 노드는 사용자가 복잡한 API 스펙을 몰라도 쉽게 쓸 수 있도록 패키징되어 있다는 점이 다릅니다.