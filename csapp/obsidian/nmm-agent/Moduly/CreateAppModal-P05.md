# 앱(App)과 워크플로우(Workflow)의 관계

이 프로젝트에서 **앱(App)**과 **워크플로우(Workflow)**는 서로 떼려야 뗄 수 없는 관계이자, 역할이 명확히 구분된 파트너입니다.

쉽게 비유하자면 다음과 같습니다.

> **앱 (App)** = 껍데기, 간판, 신분증  
> **워크플로우 (Workflow)** = 두뇌, 설계도, 엔진

---

## 1. 개념 비교

| 구분            | **앱 (App)**                           | **워크플로우 (Workflow)**                    |
| :-------------- | :------------------------------------- | :------------------------------------------- |
| **역할**        | 사용자에게 보여지는 **'제품'** 그 자체 | 앱이 실제로 작동하는 **'논리'**와 **'설정'** |
| **변경 빈도**   | 낮음 (이름이나 아이콘은 잘 안 바꿈)    | 높음 (프롬프트 수정, 모델 변경 등 잦음)      |
| **데이터 예시** | 이름, 설명, 아이콘, 배경색             | 프롬프트 내용, AI 모델 종류, 노드 연결 구조  |
| **관리 단위**   | 1개 (유일함)                           | N개 (여러 버전 존재 가능: 초안, 배포본 등)   |

## 2. 왜 나누었을까요? (분리 설계의 이유)

가장 큰 이유는 **'버전 관리(Version Control)'** 때문입니다.

만약 앱과 워크플로우가 하나로 합쳐져 있다면?

- 프롬프트를 조금만 수정해서 테스트해보고 싶은데, 수정하는 순간 실사용자들의 앱도 바로 바뀌어 버립니다. (위험!)

이렇게 둘을 나누면 다음과 같은 운영이 가능해집니다.

1.  **안전한 실험**: `App`은 그대로 두고, 연결된 `Workflow`의 '복사본(Draft)'을 만들어 마음껏 수정하고 테스트합니다.
2.  **배포(Publish)**: 테스트가 끝나면 그 `Workflow`를 '배포 버전'으로 지정하여 실제 앱에 적용합니다.
3.  **이력 관리**: 예전에 썼던 프롬프트(이전 버전 Workflow)들이 기록으로 남아 있어 언제든 되돌릴 수 있습니다.

## 3. 구조도 (Mermaid)

앱 하나에 여러 개의 워크플로우 버전이 연결될 수 있는 구조입니다.

```mermaid
graph TD
    subgraph "APP (껍데기)"
        App[📱 카피라이팅 생성기]
        AppDesc[설명: 마케팅 문구 자동 생성]
        AppIcon[아이콘: ✍️]
    end

    subgraph "WORKFLOW (두뇌)"
        WF_Draft[📝 Workflow (작성 중)]
        WF_Live[🚀 Workflow (실제 배포됨)]
        WF_Old[💾 Workflow (구버전)]
    end

    App -->|설정/수정| WF_Draft
    App -->|사용자에게 실행| WF_Live
    App -->|기록 보관| WF_Old

    WF_Draft -.->|내용| Content1["{ 프롬프트: '재밌게 써줘', 모델: GPT-4 }"]
    WF_Live -.->|내용| Content2["{ 프롬프트: '진지하게 써줘', 모델: GPT-3.5 }"]
```

## 4. 데이터베이스 필드 비교

### App (껍데기)

- `id`: 고유 식별자
- `name`: 앱 이름
- `icon`: 아이콘

### Workflow (두뇌)

- `app_id`: 소속된 앱의 ID (연결 고리)
- `graph`: 노드와 엣지의 연결 정보 (실제 로직)
- `features`: 파일 업로드 기능 등 부가 기능 설정
- `version`: 버전 정보 (draft 등)

---

_이 구조를 통해 사용자는 앱의 겉모습(App)은 유지한 채, 내부의 지능(Workflow)만 계속 똑똑하게 업그레이드할 수 있습니다._
